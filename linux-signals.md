# Linux Signals
Understanding signals are tricky in Linux. This article provides an overview of commonly encountered signals and how to handle signals in a bash script.

# What is a Signal?
A signal is an event generated by the system in response to a specific condition. When a process receives a signal it may take an action. A standard signal has a default disposition and it determines the behavior of the process after it is delivered.

Signals can be sent to a process when the system detects a software event. It can either be a user-generated signal or a process generated signal. A kernel could also send a signal when a hardware event has occurred or to note that an I/O event is completed.

The default disposition for each standard signal can be one of the following options as specified in the manpage:

```
Term   Default action is to terminate the process
Ign    Default action is to ignore the signal
Core   Default action is to terminate the process and dump core (see core(5))
Stop   Default action is to stop the process
Cont   Default action is to continue the process if it is currently stopped
```

When a process receives a signal it can choose to take one of these actions
- Execute the default disposition of the signal
- block the signal by setting a signal mask
- replace the default disposition with a custom action using the signal system call

# What are the types of signals?

Every signal falls into one of the five classes:
- Process Control
- Resource Control
- I/O Notification
- Hardware Condition
- Software Condition

Linux supports a lot of signals. You can find a lot about it on the official man page (man 7 signal). To see a list of all the available signals on the system, run the command `kill -l`

The following are the signals that are commonly encountered:

**SIGHUP (1):** If a process is running from a terminal and that terminal is closed accidentally, then the process receives this signal. “HUP” is short for “hang up” and terminates the process. If you don’t want to hang up the process when the terminal is disconnected, start the process with nohup.

**SIGINT (2):** Manual interruption of a process from a keyboard. When you hit Ctrl-C, it sends a SIGINT signal to the running process and terminates it.

**SIGQUIT(3):** When a user types <ctrl>+\ in the terminal. It will force the process to produce a core dump and will terminate the process.

**SIGKILL(9):** Forcefully terminate a process. This signal can’t be blocked or handled. The receiving process cannot perform clean up when it is terminated with SIGKILL.

**SIGPIPE (13):** Broken pipe. If a process is piping in its output to another process (producer | consumer) and if the consumer dies, the producer gets the SIGPIPE signal from the consumer, which terminates the producer process

**SIGTERM (15):** It is the software termination signal. This is the signal that is sent by the kill command by default.

**SIGCHLD(17):** This signal is sent by a child process to its parent to intimate that the child is stopped or terminated. If a child process terminates before the parent calls the wait syscall on it, the kernel tries to keep the information about the process so that the parent can later call wait to get to know the exit status. This state of the child process, where the process terminates but the entry for the child still exists on the process table of the kernel, is referred to as zombie state and the process is called the zombie process.

**SIGUSR1, SIGUSR2:** Signals reserved for developers. These signals can have a custom disposition as configured by the developer. One instance of this signal usage

# How to send a signal?
Apart from the keyboard signals like <ctrl>+\ and <ctrl>-c , the kill command can be used to send specific signals to a process by using the process’s PID.
```
# sends a SIGINT
kill -2 <pid> <pid>
# sends a SIGKILL
kill -9 <pid>
#sends a SIGQUIT
kill --signal SIGQUIT <pid>
```
If you want to delete all processes of the same type, kill-all comes in handy
```
# kills all ssh processes
kill-all ssh
```

# How to trap a signal?
This section is specific to trapping a signal in bash. The command that comes in handy to do something when the process receives a specific signal is the trap command.

The trap command can be used in shell scripts for following reasons
- cleaning up files
- Ignoring signals

```
trap commands signals
```

Example usage for trap command to cleanup before executing is as follows

```
trap "rm -f ${BASH_SOURCE%/*}/tmp_data; exit" 2
```

The above command removes the tmp_data file that gets created in the source directory of the script. The `exit` at the end is important for the process to terminate when it encounters signal 2, otherwise, the process deletes the file tmp_data and continues to execute from the point in the program where the SIGINT (2) was invoked.

# Tips and Tricks:
- Do not use the SIGKILL (9) unless you have gracefully tried to kill the process with SIGTERM
- You can choose to not do anything when encountered with a specific signal type
```
trap ‘ ‘ 2
```